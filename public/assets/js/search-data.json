{"0": {
    "doc": "在docker container中启动定时任务",
    "title": "设置cron",
    "content": "在Linux中定时任务一般使用cron，ubuntu的官方镜像中已经包含了cron，可以直接使用。但是因为cron是后台执行，我们还需要另外一个进程来保持container的运行。 可以通过使用tail -F ，来检测一些log文件保持进程，也可以在container启动的时候设置 -restart alwasy。 . 下面是以ubuntu为例的Dockerfile: . FROM ubuntu:14.04 # 安装python, 这步可以省略，或添加其他依赖 RUN apt-get update RUN apt-get install -y python # 创建脚本路径 RUN mkdir /code WORKDIR /code # 复制要运行的代码到镜像中，包括cron配置文件 ADD . /code # 设置cron脚本 RUN crontab /code/crontabfile # 安装rsyslog RUN apt-get -y install rsyslog # 复制crontabfile到/etc/crontab RUN cp /code/crontabfile /etc/crontab RUN touch /var/log/cron.log # 将run.sh设置为可执行 RUN chmod +x /code/run.sh WORKDIR /code CMD [\"bash\",\"/code/run.sh\"] . run.sh . rsyslogd cron touch /var/log/cron.log tail -F /var/log/syslog /var/log/cron.log . tail -F /var/log/syslog /var/log/cron.log这里用来输出系统和cron日志，并保持container运行 . crontabfile example . 0 23 * * * python /code/run.py cron &gt;&gt; /var/log/cron.log 2&gt;&amp;1 . python /code/run.py是要运行的定时任务。关于cron配置，可以参考这篇文章 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2016-02-21-schedule-task-in-docker.html#%E8%AE%BE%E7%BD%AEcron",
    "relUrl": "/docs/2016-02-21-schedule-task-in-docker.html#设置cron"
  },"1": {
    "doc": "在docker container中启动定时任务",
    "title": "build镜像",
    "content": "将Dockerfile, run.sh, crontabfile 放在脚本跟目录下，运行docker build -t your-image-name .创建镜像。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2016-02-21-schedule-task-in-docker.html#build%E9%95%9C%E5%83%8F",
    "relUrl": "/docs/2016-02-21-schedule-task-in-docker.html#build镜像"
  },"2": {
    "doc": "在docker container中启动定时任务",
    "title": "测试",
    "content": "在脚本根目录下创建run.py脚本来测试镜像。 . run.py . if __name__ == '__main__': print \"I am running by cron\" . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2016-02-21-schedule-task-in-docker.html#%E6%B5%8B%E8%AF%95",
    "relUrl": "/docs/2016-02-21-schedule-task-in-docker.html#测试"
  },"3": {
    "doc": "在docker container中启动定时任务",
    "title": "运行",
    "content": "在有docker engining的机器上运行docker run you-image-name启动定时任务，也可以根据具体情况添加其他启动参数。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2016-02-21-schedule-task-in-docker.html#%E8%BF%90%E8%A1%8C",
    "relUrl": "/docs/2016-02-21-schedule-task-in-docker.html#运行"
  },"4": {
    "doc": "在docker container中启动定时任务",
    "title": "代码",
    "content": "文本代码托管在yanqiw/cron-in-docker. 使用如下代码来快速运行代码： . git clone https://github.com/yanqiw/cron-in-docker.git cd cron-in-docker docker build -t cron-in-docker . docker run --rm -it cron-in-docker . container启动后，在控制台可以看到每分钟输出的”I am running by cron”. ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2016-02-21-schedule-task-in-docker.html#%E4%BB%A3%E7%A0%81",
    "relUrl": "/docs/2016-02-21-schedule-task-in-docker.html#代码"
  },"5": {
    "doc": "在docker container中启动定时任务",
    "title": "参考文章",
    "content": "aptible/docker-cron-example . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2016-02-21-schedule-task-in-docker.html#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0",
    "relUrl": "/docs/2016-02-21-schedule-task-in-docker.html#参考文章"
  },"6": {
    "doc": "在docker container中启动定时任务",
    "title": "在docker container中启动定时任务",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2016-02-21-schedule-task-in-docker.html",
    "relUrl": "/docs/2016-02-21-schedule-task-in-docker.html"
  },"7": {
    "doc": "使用docker创建ReactJS开发环境，实时编译JSX",
    "title": "为什么要使用docker来创建ReactJS开发环境",
    "content": "刚刚开始学习ReactJS的时候，折腾了很久才搭建起开发环境。所以，我就开始尝试将ReactJS的编译环境打包在docker中，并使用gulp来动态编译。后来一直在使用这个docker镜像，来帮助我开发ReactJS应用。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-03-05-use-docker-build-reactjs.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8docker%E6%9D%A5%E5%88%9B%E5%BB%BAreactjs%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83",
    "relUrl": "/docs/react-native/2016-03-05-use-docker-build-reactjs.html#为什么要使用docker来创建reactjs开发环境"
  },"8": {
    "doc": "使用docker创建ReactJS开发环境，实时编译JSX",
    "title": "使用到的技术",
    "content": ". | docker | gulp | browserify | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-03-05-use-docker-build-reactjs.html#%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF",
    "relUrl": "/docs/react-native/2016-03-05-use-docker-build-reactjs.html#使用到的技术"
  },"9": {
    "doc": "使用docker创建ReactJS开发环境，实时编译JSX",
    "title": "创建镜像",
    "content": "首先，要根据自己的需要创建一个reactJS编译环境的镜像。 . Dockerfile . FROM node RUN mkdir /runtime WORKDIR /runtime RUN npm init -y #install gulp for auto build RUN npm install --save-dev gulp gulp-uglify; RUN npm install --save-dev del; RUN npm install --save-dev vinyl-source-stream; RUN npm install --save-dev browserify; RUN npm install --save-dev reactify; RUN npm install --save-dev react react-dom; #install react and build tool #RUN npm install -g browserify #RUN npm install --save-dev react react-dom babelify babel-preset-react #add gulpfile ADD . /runtime CMD [\"bash\", \"run.sh\"] . gulpfile.js用来定义gulp要做的事情。 . gulpfile.js . /* gulpfile.js */ // Load some modules which are installed through NPM. var gulp = require('gulp'); var browserify = require('browserify'); // Bundles JS. var del = require('del'); // Deletes files. var reactify = require('reactify'); // Transforms React JSX to JS. var source = require('vinyl-source-stream'); // Define some paths. var paths = { app_js: ['./src/js/app.js'], js: ['./src/js/*.js'], }; // An example of a dependency task, it will be run before the css/js tasks. // Dependency tasks should call the callback to tell the parent task that // they're done. gulp.task('clean', function(done) { del(['build'], done); }); // Our JS task. It will Browserify our code and compile React JSX files. gulp.task('js', function() { // Browserify/bundle the JS. console.log('trigger browserify'); browserify(paths.app_js) .transform(reactify) .bundle() .pipe(source('bundle.js')) .pipe(gulp.dest('./src/')); }); gulp.task('called', function(){ console.log(\"Call\"); }) // Rerun tasks whenever a file changes. gulp.task('watch', function() { gulp.watch(paths.js, ['called','js']); }); // The default task (called when we run `gulp` from cli) gulp.task('default', ['watch', 'js']); . run.sh用启动gulp脚本，对本地文件进行监视，一旦有文件改动，立即执行编译。 . run.sh . #!/usr/bin/bash ./node_modules/gulp/bin/gulp.js . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-03-05-use-docker-build-reactjs.html#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F",
    "relUrl": "/docs/react-native/2016-03-05-use-docker-build-reactjs.html#创建镜像"
  },"10": {
    "doc": "使用docker创建ReactJS开发环境，实时编译JSX",
    "title": "镜像构建",
    "content": "将Dockerfile,gulpfile.js, run.sh三个文件放在同一目录下。 运行 . docker build -t reactjs-builder-runtime . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-03-05-use-docker-build-reactjs.html#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA",
    "relUrl": "/docs/react-native/2016-03-05-use-docker-build-reactjs.html#镜像构建"
  },"11": {
    "doc": "使用docker创建ReactJS开发环境，实时编译JSX",
    "title": "运行",
    "content": "在项目静态文件夹中运行，请将ReactJS项目入口文件名设置为app.js。 如果项目的入口文件不是app.js,可以修改gulpfile.js中的路径设置。 . docker run --name project-name-reactjs-builder -v \"$PWD\":/runtime/src -d reactjs-builder-runtime . 查看日志： . docker logs -f project-name-reactjs-builder . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-03-05-use-docker-build-reactjs.html#%E8%BF%90%E8%A1%8C",
    "relUrl": "/docs/react-native/2016-03-05-use-docker-build-reactjs.html#运行"
  },"12": {
    "doc": "使用docker创建ReactJS开发环境，实时编译JSX",
    "title": "代码和镜像托管",
    "content": ". | 项目代码托管在yanqiw/reactjs-builder-runtime | 镜像托管在react-runtime | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-03-05-use-docker-build-reactjs.html#%E4%BB%A3%E7%A0%81%E5%92%8C%E9%95%9C%E5%83%8F%E6%89%98%E7%AE%A1",
    "relUrl": "/docs/react-native/2016-03-05-use-docker-build-reactjs.html#代码和镜像托管"
  },"13": {
    "doc": "使用docker创建ReactJS开发环境，实时编译JSX",
    "title": "参考文章",
    "content": ". | TBD | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-03-05-use-docker-build-reactjs.html#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0",
    "relUrl": "/docs/react-native/2016-03-05-use-docker-build-reactjs.html#参考文章"
  },"14": {
    "doc": "使用docker创建ReactJS开发环境，实时编译JSX",
    "title": "使用docker创建ReactJS开发环境，实时编译JSX",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-03-05-use-docker-build-reactjs.html",
    "relUrl": "/docs/react-native/2016-03-05-use-docker-build-reactjs.html"
  },"15": {
    "doc": "React Native入门总结",
    "title": "React Native入门总结",
    "content": "用Javascript, HTML, CSS开发APP已经被谈论了很多年了，在React Native之前， Cordova一直是首选， 在Cordova的基础上有很多优秀的框架，但是WebView的性能始终是纯H5技术的APP无法跨越的沟， 在用户体验至上的今天，性能问题变得尤为重要。 React Native通过编译将web的组件转换成native的组件，很大的提升了APP的性能。 目前，React Native支持Android和iOS两大主流平台，并被应用在很多知名项目中。 . 下面是cordova和React Native的架构图，可以很容易看出两者的不同之处： . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html"
  },"16": {
    "doc": "React Native入门总结",
    "title": "Cordova架构",
    "content": "图片来自Cordova官网 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#cordova%E6%9E%B6%E6%9E%84",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#cordova架构"
  },"17": {
    "doc": "React Native入门总结",
    "title": "React Native架构",
    "content": "图片来自React Native: Into a new world of rapid iOS development . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#react-native%E6%9E%B6%E6%9E%84",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#react-native架构"
  },"18": {
    "doc": "React Native入门总结",
    "title": "准备工作",
    "content": "再开始React Native之前，需要准备安装： . | Node | Android SKD (for android) | Xcode (for iOS) | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#准备工作"
  },"19": {
    "doc": "React Native入门总结",
    "title": "开发用具:",
    "content": "因为开发React Native用到的是Javascript，所以可选择的空间很大，首推的还是JetBrains家的WebStorm， 如果觉得太重GitHub家的Atom也是不错的选择，加上Facebook新推出的插件Nuclide也是很强大的。 . 注意：在Windows上面有时候Atom会占用大量CPU资源，导致笔记本发热严重. 建议在windows上使用Sublime编辑器。 . Android开发推荐Android Studio。 . iOS开发没得选，直接从App Store下载xCode。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E5%BC%80%E5%8F%91%E7%94%A8%E5%85%B7",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#开发用具"
  },"20": {
    "doc": "React Native入门总结",
    "title": "安装React Native",
    "content": "下面步骤基于Mac OS X系统。 对于其他操作系统，你可以参考React Native官网安装 . 安装Node . 安装Homebrew . 在Mac上使用brew安装nodejs是非常方便的， 如果你已经有了Homebrew可以直接跳过这步。 打开Terminal运行： . /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" . 安装Node . React Native需要4.0以上的版本。Homebrew会安装最新的6.0版本。 . sudo npm install -g react-native-cli . 安装Android Studio . 在android stuido官网下载安装包并安装。安装后，需要下载SKD。选择：Android Studio &gt; Preference &gt; System Settings &gt; Android SDK中选择相应的android版本的SKD。 . 建议使用5.0以上的Android版本用于开发和调试，稳定性会远高于4.0+版本。 . 设置ANDROID_HOME环境变量，这部很重要，如果稍后React Native运行不了，多半是这里设置的不正确。 打开 ~/.bashrc或~/.bash_profile, 如果没有运行 . touch ~/.bashrc # or ~/.bash_profile . 在文件中输入下面命令： . # 如果SDK不是通过android studio安装的， 那么它可能在以下路径: # /usr/local/opt/android-sdk export ANDROID_HOME=~/Library/Android/sdk . 安装Watchman . 建议安装Watchman来监控文件夹变化, 自动触发一些事件 . brew install watchman . 安装Genymotion . 强烈推荐的模拟器，可以方便的安装不同型号的Android手机模拟器。 . | 在Genymotion官网注册账号 | 登陆后在下载页面下载安装包 | 根据说明安装 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E5%AE%89%E8%A3%85react-native",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#安装react-native"
  },"21": {
    "doc": "React Native入门总结",
    "title": "创建项目",
    "content": "创建一个React Native项目很简单，至于要一行命令： . react-native init AwesomeProject cd AwesomeProject npm install . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#创建项目"
  },"22": {
    "doc": "React Native入门总结",
    "title": "运行Android项目",
    "content": ". | 运行一个Genymotion的虚拟机 | 在AwesomeProject文件夹下运行react-native run-android | . 刚刚初始化的项目会被编译并安装在虚拟机中， 在编辑器中打开AwesomeProject文件夹，就可以进行开发项目了。 . 第一次启动时会下载依赖包，需要耐心等待很久。 根据网络情况，你可能需要设置代理才能完成下载。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E8%BF%90%E8%A1%8Candroid%E9%A1%B9%E7%9B%AE",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#运行android项目"
  },"23": {
    "doc": "React Native入门总结",
    "title": "运行iOS项目",
    "content": "在AwesomeProject文件夹下运行react-native run-ios。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E8%BF%90%E8%A1%8Cios%E9%A1%B9%E7%9B%AE",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#运行ios项目"
  },"24": {
    "doc": "React Native入门总结",
    "title": "第一枪",
    "content": "在虚拟设备上运行的时候，一切会很顺利，但是第一次将项目放到真实android设备中运行时，大多数人都会中上React Native的第一枪－Can't find variable: _fbBatchedBridge。 . 有时也可能是一个大白页面。 . 解决办法也很简单，在Dev setting里面设置电脑的IP:8081，再刷新就可以解决。 . 很多国内定制版的android系统不能通过menu键调出Dev setting。 这时需要在手机的设置-&gt;应用-&gt;[项目app]-&gt;权限管理中启动显示悬浮窗口。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E7%AC%AC%E4%B8%80%E6%9E%AA",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#第一枪"
  },"25": {
    "doc": "React Native入门总结",
    "title": "修改项目",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#修改项目"
  },"26": {
    "doc": "React Native入门总结",
    "title": "Android",
    "content": "使用之前介绍人任何一款编辑器打开AwesomeProject中的index.android.js,并加入自己的代码，开始你的项目。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#android",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#android"
  },"27": {
    "doc": "React Native入门总结",
    "title": "iOS",
    "content": "index.ios.js是iOS的入口文件，可以参考React Native官方网站进行项目开发，这里不过多介绍。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#ios",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#ios"
  },"28": {
    "doc": "React Native入门总结",
    "title": "调试",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E8%B0%83%E8%AF%95",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#调试"
  },"29": {
    "doc": "React Native入门总结",
    "title": "在Android模拟器上调试",
    "content": "运行Genymontion选择一个模拟器运行。在项目路径运行react-native run-android。项目启动后，可以通过菜单模拟键调出开发者菜单，选择reload javascript来刷新修改后的代码。也可以开启调.试模式。 . 开启调试模式的时候会弹出浏览器，这里需要手动打开开发者工具才能看到控制台和调试 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E5%9C%A8android%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8A%E8%B0%83%E8%AF%95",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#在android模拟器上调试"
  },"30": {
    "doc": "React Native入门总结",
    "title": "在Android设备上调试",
    "content": "在Android设备上打开调试模式， 并将设备通过数据线连接到电脑上运行react-native run-android。 . 请关闭其他android虚拟机，以避免安装应用到设备时出现错误。如果设备上启动应用后白屏，请参考第一枪这一段。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E5%9C%A8android%E8%AE%BE%E5%A4%87%E4%B8%8A%E8%B0%83%E8%AF%95",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#在android设备上调试"
  },"31": {
    "doc": "React Native入门总结",
    "title": "发布",
    "content": "待续 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E5%8F%91%E5%B8%83",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#发布"
  },"32": {
    "doc": "React Native入门总结",
    "title": "后续反思",
    "content": "待续 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-05-12-react-native-guide.html#%E5%90%8E%E7%BB%AD%E5%8F%8D%E6%80%9D",
    "relUrl": "/docs/react-native/2016-05-12-react-native-guide.html#后续反思"
  },"33": {
    "doc": "React Native 0.27.x adopt to xcode 8",
    "title": "React Native 0.27.0 adopt to xcode 8",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-10-05-react-native-adopt-to-xcode8.html#react-native-0270-adopt-to-xcode-8",
    "relUrl": "/docs/react-native/2016-10-05-react-native-adopt-to-xcode8.html#react-native-0270-adopt-to-xcode-8"
  },"34": {
    "doc": "React Native 0.27.x adopt to xcode 8",
    "title": "RCTSRWEBSOCKET.M error",
    "content": "Ignoring return value of function declared with warn_unused_result attribute . Find line . SecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key); . Change to . (void)SecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key); . Find line . SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes); . Change to . (void)SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes); . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-10-05-react-native-adopt-to-xcode8.html#rctsrwebsocketm-error",
    "relUrl": "/docs/react-native/2016-10-05-react-native-adopt-to-xcode8.html#rctsrwebsocketm-error"
  },"35": {
    "doc": "React Native 0.27.x adopt to xcode 8",
    "title": "RCTSCROLLVIEW.M error",
    "content": "refer to #7c8b914 to change the node_modules/react-native/React/Views/RCTScrollView.m file. Then find below code in the RCTScrollView.m file: . - (NSArray&lt;UIView *&gt; *)reactSubviews { if (_contentView &amp;&amp; _scrollView.refreshControl) { return @[_contentView, _scrollView.refreshControl]; } return _contentView ? @[_contentView] : @[]; } . change to . - (NSArray&lt;UIView *&gt; *)reactSubviews { if (_contentView &amp;&amp; _scrollView.rctRefreshControl) { return @[_contentView, _scrollView.rctRefreshControl]; } return _contentView ? @[_contentView] : @[]; } . Example of the changed RCTScrollView.m in Gist . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-10-05-react-native-adopt-to-xcode8.html#rctscrollviewm-error",
    "relUrl": "/docs/react-native/2016-10-05-react-native-adopt-to-xcode8.html#rctscrollviewm-error"
  },"36": {
    "doc": "React Native 0.27.x adopt to xcode 8",
    "title": "React Native 0.27.x adopt to xcode 8",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2016-10-05-react-native-adopt-to-xcode8.html",
    "relUrl": "/docs/react-native/2016-10-05-react-native-adopt-to-xcode8.html"
  },"37": {
    "doc": "Redux Saga实践",
    "title": "Redux Saga 实践",
    "content": "本文用以记录从调研Redux Saga，到应用到项目中的一些收获。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#redux-saga-%E5%AE%9E%E8%B7%B5",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#redux-saga-实践"
  },"38": {
    "doc": "Redux Saga实践",
    "title": "什么是Redux Saga",
    "content": "官网解释 来自：https://github.com/redux-saga/redux-saga . redux-saga is a library that aims to make side effects (i.e. asynchronous things like data fetching and impure things like accessing the browser cache) in React/Redux applications easier and better. The mental model is that a saga is like a separate thread in your application that’s solely responsible for side effects. redux-saga is a redux middleware, which means this thread can be started, paused and cancelled from the main application with normal redux actions, it has access to the full redux application state and it can dispatch redux actions as well. 刚开始了解Saga时，看官方解释，并不是很清楚到底是什么？Saga的副作用(side effects)到底是什么? . 通读了官方文档后，大概了解到，副作用就是在action触发reduser之后执行的一些动作， 这些动作包括但不限于，连接网络，io读写，触发其他action。并且，因为Sage的副作用是通过redux的action触发的，每一个action，sage都会像reduser一样接收到。并且通过触发不同的action, 我们可以控制这些副作用的状态， 例如，启动，停止，取消。 . 所以，我们可以理解为Sage是一个可以用来处理复杂的异步逻辑的模块，并且由redux的action触发。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E4%BB%80%E4%B9%88%E6%98%AFredux-saga",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#什么是redux-saga"
  },"39": {
    "doc": "Redux Saga实践",
    "title": "使用Saga解决的问题",
    "content": "最初，在开始探究Saga之前，我们是希望寻求一种方式来隔离开应用前端的展现层，业务层和数据层。 大概想法是使用react展现数据，redux管理数据，然后借助redux的middleware来实现业务层。这样原有的react为核心的项目架构，变成了redux为核心的架构。 . 在最初的调研中redux-thunk是首先考虑的，redux-thunk是在action作用到reducer之前触发一些业务操作。刚好起到控制层的作用。 . 但是，马上了解到了redux-sage，因为大家都在对比两者。本文并不会做对比，在文章的最后会简单介绍为什么选了Saga而不是thunk的原因，仅供参考。 . 在浏览了很多比较文章后，最终，我们选择了redux-saga来处理应用的控制层。 . 下面是一个简单的例子： . 在用户提交表单的时候，我们想要做如下事情： . | 校验一些输入信息 (简单， 写在组件里) | 弹起提示信息（聪明的我，一定要写一个公用的提示信息模块，这样别的页面引入就可以用了， 呵呵呵呵。。。） | 提交后端服务 （直接组件里面fetch吧。。。） | 拿到后端返回状态 （promise so easy…） | 隐藏提示信息 (这个有点难度，不过难不倒我，我给组建加一个控制属性) | 更新redux store （dispatch咯。。。） | . 好了，现在我们要把刚刚做的事情加到所有的表单上。。。 （WTF, 每个form组件都要做同样的事情。。。页面的代码丑的不想再多看一眼。。。） . 用了redux-saga之后： . | form组件触发提交action (一行简单的dispatch) | reducer这个action不需要我处理 （打酱油了） | saga提交表单的副作用走起～ （监听到触发副作用的action） . | 校验一下 | 通知显示层弹起信息框 （dispatch一下变更控制信息框弹起的store） | 提交表单 (yield一个promis，yield是javascript generator的语法，稍后有介绍) | 拿到后端返回状态 | 更新redux store (dispatch一下) | . | . 可以看到在使用了Saga后，react只负责数据如何展示，redux来负责数据的状态和绑定数据到react，而Saga处理了大部分复杂的业务逻辑。 . 通过这个改变，前端应用的代码结构更加清晰，业务层可复用的部分增加。当然，Saga对自动化测试也支持的很好，可以将逻辑单独使用自动化脚本测试，提高项目质量。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E4%BD%BF%E7%94%A8saga%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#使用saga解决的问题"
  },"40": {
    "doc": "Redux Saga实践",
    "title": "开始前需要了解的几个概念",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E5%BC%80%E5%A7%8B%E5%89%8D%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#开始前需要了解的几个概念"
  },"41": {
    "doc": "Redux Saga实践",
    "title": "redux中间件",
    "content": "redux中文文档解释如下： . 如果你使用过 Express 或者 Koa 等服务端框架, 那么应该对 middleware 的概念不会陌生。 在这类框架中，middleware 是指可以被嵌入在框架接收请求到产生响应过程之中的代码。例如，Express 或者 Koa 的 middleware 可以完成添加 CORS headers、记录日志、内容压缩等工作。middleware 最优秀的特性就是可以被链式组合。你可以在一个项目中使用多个独立的第三方 middleware。 . 相对于 Express 或者 Koa 的 middleware，Redux middleware 被用于解决不同的问题，但其中的概念是类似的。它提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。 . 可以简单理解为，中间件是可以在action到达reducer之前做一些事情的层。（有意思的是，saga应该是在reducer被触发之后才触发的。TODO, 需要进一步验证） . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#redux%E4%B8%AD%E9%97%B4%E4%BB%B6",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#redux中间件"
  },"42": {
    "doc": "Redux Saga实践",
    "title": "Javascript Generator",
    "content": "在使用Saga之前，建议先了解Javascript生成器，因为Saga的副作用都是通过生成器来实现的。 . 可以在阮一峰的ECMAScript 6 入门: Generator 函数的语法和Generator 函数的异步应用章节中了解更多细节。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#javascript-generator",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#javascript-generator"
  },"43": {
    "doc": "Redux Saga实践",
    "title": "如何使用",
    "content": "redux-sage官方文档有很详细的使用说明，这里只做简单的上手说明。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#如何使用"
  },"44": {
    "doc": "Redux Saga实践",
    "title": "安装redux-sage",
    "content": "npm install --save redux-saga . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E5%AE%89%E8%A3%85redux-sage",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#安装redux-sage"
  },"45": {
    "doc": "Redux Saga实践",
    "title": "给redux添加中间件",
    "content": "在定义生成store的地方，引入并加入redux-sage中间件。 . import { createStore, applyMiddleware } from 'redux' import createSagaMiddleware from 'redux-saga' import reducer from './reducers' import mySaga from './sagas' // create the saga middleware const sagaMiddleware = createSagaMiddleware() // mount it on the Store const store = createStore( reducer, applyMiddleware(sagaMiddleware) ) // then run the saga sagaMiddleware.run(mySaga) . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E7%BB%99redux%E6%B7%BB%E5%8A%A0%E4%B8%AD%E9%97%B4%E4%BB%B6",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#给redux添加中间件"
  },"46": {
    "doc": "Redux Saga实践",
    "title": "副作用",
    "content": "副作用，顾名思义，在主要作用（action触发reducer）之外，用来处理其他业务逻辑。redux-saga提供了几种产生副作用的方式, 主要用到了有两种takeEvery和takeLates。 . takeEvery会在接到相应的action之后不断产生新的副作用。 比如，做一个计数器按钮，用户需要不断的点击按钮，对后台数据更新，这里可以使用takeEvery来触发。 . takeLatest在相同的action被触发多次的时候，之前的副作用如果没有执行完，会被取消掉，只有最后一次action触发的副作用可以执行完。比如，我们需要一个刷新按钮， 让用户可以手动的从后台刷新数据， 当用户不停单机刷新的时候， 应该最新一次的请求数据被刷新在页面上，这里可以使用takeLatest。 . import { call, put } from 'redux-saga/effects' import { takeEvery } from 'redux-saga' export function* fetchData(action) { try { const data = yield call(Api.fetchUser, action.payload.url); yield put({type: \"FETCH_SUCCEEDED\", data}); } catch (error) { yield put({type: \"FETCH_FAILED\", error}); } } function* watchFetchData() { yield* takeEvery('FETCH_REQUESTED', fetchData) } . 注意，takeEvery第一个参数可以是数组或者方法。 也可以有第三个参数用来传递变量给方法。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E5%89%AF%E4%BD%9C%E7%94%A8",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#副作用"
  },"47": {
    "doc": "Redux Saga实践",
    "title": "call方法",
    "content": "call有些类似Javascript中的call函数， 不同的是它可以接受一个返回promise的函数，使用生成器的方式来把异步变同步。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#call%E6%96%B9%E6%B3%95",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#call方法"
  },"48": {
    "doc": "Redux Saga实践",
    "title": "put方法",
    "content": "put就是redux的dispatch，用来触发reducer更新store . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#put%E6%96%B9%E6%B3%95",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#put方法"
  },"49": {
    "doc": "Redux Saga实践",
    "title": "有什么弊端",
    "content": "目前在项目实践中遇到的一些问题： . | redux-saga模型的理解和学习需要投入很多精力 | 因为需要用action触发，所以会产生很多对于reducer无用的action, 但是reducer一样会跑一轮，虽然目前没有观测到性能下降，但还是有计算开销 | 在action的定义上要谨慎，避免action在saga和reducer之间重复触发，造成死循环 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%8A%E7%AB%AF",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#有什么弊端"
  },"50": {
    "doc": "Redux Saga实践",
    "title": "后记",
    "content": "总体而言，对于redux-saga的第一次尝试还是很满意的。 在业务逻辑层，可以简化代码，使代码更加容易阅读。 在重用方面，解耦显示层和业务层之后， 代码的重用度也得到了提升。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E5%90%8E%E8%AE%B0",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#后记"
  },"51": {
    "doc": "Redux Saga实践",
    "title": "选择Saga的原因",
    "content": "开始的时候一直在犹豫是否需要使用Saga或thunk，因为并不能很好的把握这两者到底解决了什么问题。之后，在浏览文章的时候看到了一遍对比两者的长文，列出了不少开发者对两者的担忧和争论，其中不乏闪光的观点，长文的最后作者写到：“不管是否用得上，你都应该尝试一下”。 这句话使我决定了尝试用saga或thunk来实践把前端分层的设想。 . 之所以最后选择了saga是因为这段 Cheng Lou 的视频： On the Spectrum of Abstraction (youtube) . 视频中讲述了在一种抽象的概念下如何去选择一种技术。 其中一个理论是：越是用来解决具体问题的技术，使用起来越容易，越高效，学习成本越低；越是用来解决宽泛问题的技术，使用起来越难，学习成本越高。 thunk解决的是很具体的一个问题，就是在action到达reducer之前做一些其他的业务，比如fetch后端, 它在做这件事的上很高效。而Saga解决的问题要更宽泛一些，因为saga只是拦截了action，至于做什么，开发者需要自己来考虑，可以是fetch后端，也可以是更新redux store, 甚至可以执行action带进来的callback。 很显然对于一个业务层来说,saga会是一个更合适的选择，但同时也带来了学习成本的提高。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html#%E9%80%89%E6%8B%A9saga%E7%9A%84%E5%8E%9F%E5%9B%A0",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html#选择saga的原因"
  },"52": {
    "doc": "Redux Saga实践",
    "title": "Redux Saga实践",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2017-03-05-redux-saga.html",
    "relUrl": "/docs/react-native/2017-03-05-redux-saga.html"
  },"53": {
    "doc": "餐饮圈后端容器化实践",
    "title": "餐饮圈后端容器化实践",
    "content": "记录餐饮圈APP后端容器化技术选型，以及实践过程。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html"
  },"54": {
    "doc": "餐饮圈后端容器化实践",
    "title": "项目介绍",
    "content": "简单介绍一下餐饮圈项目规模，以及团队配置，用以作为技术选型和实践的参考条件。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#项目介绍"
  },"55": {
    "doc": "餐饮圈后端容器化实践",
    "title": "餐饮圈介绍",
    "content": "餐饮圈是专注于餐饮行业社交，招聘的APP。 后端采用微服务的设计思想，将不同的业务放在不同服务中。 随着业务的发展，目前后端服务有20多个。 . 容器化之前，采用的是传统的负载均衡（阿里云负载均衡） + 多台服务器（阿里云ECS） + 数据库（阿里云RDS)模式。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E9%A4%90%E9%A5%AE%E5%9C%88%E4%BB%8B%E7%BB%8D",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#餐饮圈介绍"
  },"56": {
    "doc": "餐饮圈后端容器化实践",
    "title": "团队规模介绍",
    "content": "研发团队3～5人，同时负责前端APP和后端的研发和运维。日常的开发流程采用敏捷开发的scrum方法。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E5%9B%A2%E9%98%9F%E8%A7%84%E6%A8%A1%E4%BB%8B%E7%BB%8D",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#团队规模介绍"
  },"57": {
    "doc": "餐饮圈后端容器化实践",
    "title": "一个简单的目标 — 不断提升生产力",
    "content": "__不断提升生产力__是促使团队尝试容器化后端的主要动力。 随着后端服务的增多，在服务管理方面投入的时间增多， 团队注意到用于发布，调试和监控服务的时间越来越多。 因为之前采用的是单一tomcat运行所有服务，导致每一个服务的变更都需要重启整个tomcat。 tomcat也占用了大量的服务器内存。 . 于是，列出了希望提升的几个点： . | 更简化的发布部署方法 | 更灵活管理服务对资源的使用 | 更高效的管理服务器资源，实现快速弹性伸缩 | . 基于以上三点，团队开始考虑容器化后端，使用容器编排平台来管理服务。 . 注意：容器化后端，并不是解决上面问题的唯一选择。后来的实践中也渐渐体会到，容器化后端是很重大的决定，改变的是整个后端的基础架构。之所以没有过多犹豫就选择容器化方案，是因为团队内有人熟悉容器，而且现有后端基础架构相对简单。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%9B%AE%E6%A0%87--%E4%B8%8D%E6%96%AD%E6%8F%90%E5%8D%87%E7%94%9F%E4%BA%A7%E5%8A%9B",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#一个简单的目标--不断提升生产力"
  },"58": {
    "doc": "餐饮圈后端容器化实践",
    "title": "第一张架构总览",
    "content": "项目后端在阿里云上，持久化存储用的全部是阿里云的服务。 数据库使用RDS， 图片等静态文件使用OSS， Redis使用云数据库Redis，所以容器化过程不存在应用服务器有持久化数据的问题， 只需要保证容器平台可以顺利链接阿里云服务器即可。 . 注：应用服务器无状态化是容器化之前很关键的点，如果应用服务器上存有数据，例如图片， 缓存等，需要先将这些数据转移到云平台的存储服务中， 可以参考12 Factor App篇文章。 . 下面是第一张架构总览， 简单的从逻辑层面描述了容器化后的后端架构。 . 可以看到容器编排平台是架构的核心，所以选择一个适合的容器编排平台是容器化后端的关键。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E7%AC%AC%E4%B8%80%E5%BC%A0%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#第一张架构总览"
  },"59": {
    "doc": "餐饮圈后端容器化实践",
    "title": "容器编排平台的选择",
    "content": "我们选择了三个容器编排平台作为备选方案： . | Docker Swarm | Kubernetes | Rancher | . Docker Swarm作为Docker自家出品的容器编排服务，和Docker无缝连接，实施简单，学习曲线平滑，了解Docker使用的程序员可以很容掌握。而且，阿里云容器服务也采用了Docker Swarm作为基础。 . Kubernetes, 很多大厂用它实现了PaaS服务， 在企业级解决方案中Kubernetes也经常被采用作为PaaS平台的基础，可以侧面体现出Kubernetes的可靠性，稳定性等优势。作为Google自家集群管理工具的开源版本，Kubernetes有很高的呼声。 . Rancher相对于前两个选择，有着开箱即用的特性，提供了完整的UI控制台。在集群管理方面有多种选择，可以选择Kubernetes, Docker Swarm来做容器编排。 但是因为国内相关实践例子不多，很快就被从选项中去掉。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E5%B9%B3%E5%8F%B0%E7%9A%84%E9%80%89%E6%8B%A9",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#容器编排平台的选择"
  },"60": {
    "doc": "餐饮圈后端容器化实践",
    "title": "尝试阿里云容器服务 - Docker Swarm",
    "content": "第一个POC是在阿里云容器服务上做的，因为阿里云容器服务采用Docker Swarm基础， 而且提供了一套完成的UI控制界面。 借助官方提供的文档，一天内完成了三台服务器节点的测试集群搭建，并发布了几个测试服务。一切进行的很顺利。第二天，陆续将全部服务都部署上去，并开始性能和压力测试。 . 阿里云容器服务架构如下(来自官方文档)： . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E5%B0%9D%E8%AF%95%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1---docker-swarm",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#尝试阿里云容器服务---docker-swarm"
  },"61": {
    "doc": "餐饮圈后端容器化实践",
    "title": "第一个问题",
    "content": "在测试过程中，遇到了第一个问题，响应时间不稳定。 有些服务第一次请求响应时间在几千毫秒到几百毫秒波动， 并不稳定。 . 翻阅了路由部分的文档，找到了请求如何在平台内路由的示意图如下： . 可以看到routing容器起到了服务发现和路由转发的作用， 负载之后所有请求都会经过routing容器。 容器内是HAProxy做请求转发。 . 因为请求经过负载，又经过routing容器，然后由虚拟网络层在集群内转发到提供服务的容器。 此过程，在请求到达服务容器之前都没有日志可以跟踪，始终无法知道延迟出现在哪一步。 . 再后来的实施中这个问题随着增加服务容器实例的个数得到缓解，但是始终没有找问题的根本原因（并不能排除应用层本身有的问题的可能）。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#第一个问题"
  },"62": {
    "doc": "餐饮圈后端容器化实践",
    "title": "雪崩",
    "content": "压力测试过程中，集群出现了第一次雪崩，三个节点全部掉线，并且无法ssh登录。 调查雪崩原因有两个： . | 没有限制容器使用资源，导致容器过载后瞬间吃掉系统内存 （参考阿里云文档解决） | Tomcat官方镜像并不能很准确的计算出JVM的最大使用内存是多少，导致服务容器过载后不断重启。（具体解决办法可参考这篇文章） | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E9%9B%AA%E5%B4%A9",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#雪崩"
  },"63": {
    "doc": "餐饮圈后端容器化实践",
    "title": "结论",
    "content": "优势 . | 阿里云容器服务，提供了类似Rancher的开箱即用的特性，只需要将云服务器配置到集群中就可以自动完成集群的部署。 并且可以通过控制台界面，快速完成阿里云日志服务，云监控等功能的集成。 对于没有专门运维人员的小团队，能节省很多维护时间。 . | Docker Swarm作为基础架构，开发团队学习曲线平滑，只需要掌握docker基本知识就可以上手使用。 . | . 有待解决的问题 . | 集群使用的etcd作为一个外部服务独立提供，对于用户不可见，也不可控。 | 请求链路不完全透明，链路跟踪有难度 | 技术支持需要在群里喊。 当然群里管理员很负责，阿里云工程师都很专业，问题基本可以很快解决。但感觉技术支持的流程还不是太规范。 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E7%BB%93%E8%AE%BA",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#结论"
  },"64": {
    "doc": "餐饮圈后端容器化实践",
    "title": "尝试Kubernetes集群",
    "content": "虽然Kubernetes提供了在AWS等云上的部署的驱动，但是对于阿里云，目前并没有集成进去。 所以，我们参考了阿里云初扬写当 Kubernetes 遇到阿里云 之 快速部署1.6.1版本做POC。 对于刚刚接触Kubernetes的人来说，这很有挑战。 . 依然从三节点的测试集群开始，但马上遇到了虚拟网络层的问题， 在经典网络模式下始终无法在集群内联通虚拟网络。 几次尝试未果后，转移到VPC网络，成功建立了集群，并打通了虚拟网络。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E5%B0%9D%E8%AF%95kubernetes%E9%9B%86%E7%BE%A4",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#尝试kubernetes集群"
  },"65": {
    "doc": "餐饮圈后端容器化实践",
    "title": "集群成功运行 —— 只是个开始",
    "content": "经过两天的折腾，Kubernetes集群搭建完成。 但是还有很多东西需要完善， 控制台UI界面，服务发现，日志，监控。 很显然这些都不在Kubernetes的核心中。 所有都需要借助其他开源项目来搭建，需要投入更多的人力和时间去完善。 对于小团队来说，希望将Kubernetes用于微服务架构的生产环境，挑战很大。咨询过一些前辈后，了解到在Kubernetes上部署Spring Cloud是一个用于微服务的选择，但是并没有继续尝试。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E9%9B%86%E7%BE%A4%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C--%E5%8F%AA%E6%98%AF%E4%B8%AA%E5%BC%80%E5%A7%8B",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#集群成功运行--只是个开始"
  },"66": {
    "doc": "餐饮圈后端容器化实践",
    "title": "结论",
    "content": "优势 . Kubernetes优势很多，比如大厂都在用， 社区很活跃。 但我们最终并没有完整实践Kubernetes，所以没有办法谈对这些优势的体会。 . 对于小团队来说的挑战 . | 阿里云上部署需要了解很多Kubernetes的基础组件，其中虚拟网络层搭建挑战很大 | 如果希望用于生产环境，需要自行搭建高可用架构，并且搭建控制台，服务发现， 日志等应用。 （可以参考在阿里云上部署生产级别Kubernetes集群了解部署高可用集群的方法，但文章中也没有提到微服务相关的工具如何搭建） | 微服务平台相关组件都需要自行部署和配置 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E7%BB%93%E8%AE%BA-1",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#结论-1"
  },"67": {
    "doc": "餐饮圈后端容器化实践",
    "title": "选择 —— 阿里云容器服务",
    "content": "经过对两个平台的POC，我们最后选择了提供了更多工具的阿里云容器服务作为容器化后端的方案。 . 对于小团队来说，容器化是为了提高生产力，开始选择容器编排平台时，我们忽略了__微服务平台__这个概念，将容器编排平台等同于了微服务平台。 在POC阶段，逐渐认识到了两者的不同，微服务平台可以构建在容器编排平台之上，也可以直接在云服务器上部署。 . 选择阿里云容器服务，其实是选择了一套微服务平台，并不单单是Docker Swarm。 . 坚持容器化后端，也是因为基于Docker的DevOps可以不局限于某种后端技术，更灵活的隔离应用运行环境，和控制应用对资源的使用。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E9%80%89%E6%8B%A9--%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#选择--阿里云容器服务"
  },"68": {
    "doc": "餐饮圈后端容器化实践",
    "title": "第二张 Architecture Overview",
    "content": "目前实施的架构总览 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E7%AC%AC%E4%BA%8C%E5%BC%A0-architecture-overview",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#第二张-architecture-overview"
  },"69": {
    "doc": "餐饮圈后端容器化实践",
    "title": "后记",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E5%90%8E%E8%AE%B0",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#后记"
  },"70": {
    "doc": "餐饮圈后端容器化实践",
    "title": "在容器化后端过程中到我们底在选择什么",
    "content": "最初我们希望通过容器化后端架构来实现提高生产力这一目标。 在技术选型的开始阶段，“选择一个适合的容器编排平台”被定义为关键技术问题。 但随着POC的深入，只选择容器编排平台并不能解决提高生产力的目标，甚至容器编排平台本身并不能直接提高生产力，对于小团队来说反而需要投入更多的人力去维护。 我们认识到， 对于一个3～5人的小团队来说，我们更需要的是一套微服务治理平台，这个平台是建立在IT基础架构之上的应用平台。而容器编排平台更像是IT基础架构针对容器的一层抽象，并不能直接满足小团队提高生产力的目标。 下图大概说明了，应用，微服务平台，容器编排平台，IT基础架构的关系。 . 所以，在容器化后端技术选型的后半程，我们更多的考量的是__如何选择一个适合的微服务平台__。最后基于阿里云容器服务，实现了我们的后端容器化的第一阶段。 因为Docker Swarm和Docker的无缝连接， 开发团队并没有花费太多精力去学习新的概念，快速的将发布运维一系列工具迁移到了容器上。 在一个月之内，保证日常业务变更的前提下，完成了后端容器化，实现了提高生产力的目标。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%8C%96%E5%90%8E%E7%AB%AF%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%88%B0%E6%88%91%E4%BB%AC%E5%BA%95%E5%9C%A8%E9%80%89%E6%8B%A9%E4%BB%80%E4%B9%88",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#在容器化后端过程中到我们底在选择什么"
  },"71": {
    "doc": "餐饮圈后端容器化实践",
    "title": "还没做的事情",
    "content": ". | 继续调研微服务平台 | 测试弹性伸缩 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2017-05-11-cyq-containerlize-practice.html#%E8%BF%98%E6%B2%A1%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85",
    "relUrl": "/docs/2017-05-11-cyq-containerlize-practice.html#还没做的事情"
  },"72": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "阿里函数计算实现简单React Native热更新后台",
    "content": "函数计算作为云计算中新一代的计算单元，有着不需要管理服务器设施和更精准的计费方式的优势。它依托于云服务商的多种云资源（对象存储，日志服务等），将需要计算的业务逻辑浓缩在一个函数中，并协调多种其他云资源。收费方式也采用按调用次数和运行时间为计费单位，使得计算资源的计费更精准。对用户来说，在保证业务正常运转的前提下，节省下不少业务闲时的服务器成本。 . 2014年AWS发布Lambda函数计算服务，经过几年的发展函数计算也越来越受到开发者的关注。 2017年，阿里云发布自己的函数计算服务 . 本文记录基于阿里云函数计算服务，简单实现app热更新后端。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html"
  },"73": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "为什么使用函数计算",
    "content": "阿里云的官方文档中介绍了几种函数计算适用的场景： . | 媒资内容分析处理：通过对象存储上传事件可以触发多个函数，完成转码、元数据抽取等功能。通过事件触发机制，您能够快速整合不同服务，构建一个弹性、高可用的视频后端系统。 | Severless后端服务：可以使用 函数计算和 API网关 构建后端，以验证和处理 API 请求。采用函数服务构建灵活拓展架构,轻松创造丰富、个性化的应用程序体验。 | IoT消息实时处理：您可以使用函数计算高效的处理实时流数据。例如，实时过滤、聚合、分析IoT设备产生的数据，并将产生的结构化数据保存到数据库中。 | . 可以看出，函数计算主要应用在事件出发-&gt;简单处理数据-&gt;存入数据库或对象存储场景下。 . 这个场景也刚好适用于APP热更新的后端的几个核心业务： . | 上传新代码：上传代码到OSS事件-&gt;分析代码-&gt;更新\u001b最新版本信息 | 发布最新代码：发布事件-&gt;查询要发布代码-&gt;发布代码到环境 | APP查询更新：最新版本查询事件-&gt;比对app版本与最新版本-&gt;返回结果 | . 从费用方面考虑，函数计算现在的免费配额基本可以满是日常试用，所以决定用函数计算来支撑热更新服务。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#为什么使用函数计算"
  },"74": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "架构总览",
    "content": "使用函数计算，主要是通过云上的资源来触发函数，然后由函数处理数据，并调度其他云资源。 热更新服务架构图 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#架构总览"
  },"75": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "基本组件",
    "content": "在热更新业务中，主要涉及了以下几个组件。 . 函数计算 . 函数计算作为承载业务的应用层，替代了传统使用ECS服务搭建的应用服务器。 . 对象存储 . 对象存储用来做简单的数据持久化和存储热更新包。 . 日志服务 . 日志在函数计算中很重要。因为函数容器在运行结束后立即被销毁，运行过程中的日志也会随着容器同事销毁。只有在函数运行时将日志输出到日志服务，才能在之后查询到函数的运行记录。也因为如此，在函数调试时，我们更需要日志服务来查看函数的运行状况。 . API网关 . API网关为函数计算提供了对外提供Web API接口的能力，同时也提供了身份认证和授权两大重要功能。在API网关中，用户可以定义提供的接口签名，并授权给特定的用户使用Web API。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#基本组件"
  },"76": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "业务流",
    "content": "上传代码 . | 用户通过OSS命令行或OSS控制台直接上传代码到指定目录 | OSS触发函数计算执行相应业务 | 函数计算将结果保存回OSS指定目录 | . 检查更新 . | APP客户端访问API网关提供的API | API网关调用函数计算检查版本 | API网关将函数计算结果返回给客户端 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E4%B8%9A%E5%8A%A1%E6%B5%81",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#业务流"
  },"77": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "基本概念",
    "content": "函数计算有几个主要的概念，在开始前需要了解。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#基本概念"
  },"78": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "角色和授权",
    "content": "函数计算本身只处理业务逻辑，当函数计算需要与阿里云上其他资源交互的时候，就需要利用阿里云的RAM(访问控制)系统来给函数一个角色和授权来和其他云资源交互。函数在运行时，可以通过默认传入函数的context变量获取角色的凭证，并扮演该角色与已授权的云资源进行交互。 . 关于如何为函数服务创建角色的详细内容可以参考应用示例2 - 授权函数访问其他云服务资源 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E8%A7%92%E8%89%B2%E5%92%8C%E6%8E%88%E6%9D%83",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#角色和授权"
  },"79": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "触发器和事件",
    "content": "事件是当其他云资源需要触发函数计算处理时，发送给函数计算服务的一段包含特定事件详情的信息。其他云资源可以定义什么时候触发事件（即定义触发器），不同资源，触发事件后发送给函数计算的事件详情不同。 . 注：目前阿里云上只有AIP网关和OSS对象存储支持创建触发器。 . 更多细节可参考应用示例4 - 触发器管理 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E8%A7%A6%E5%8F%91%E5%99%A8%E5%92%8C%E4%BA%8B%E4%BB%B6",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#触发器和事件"
  },"80": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "服务",
    "content": "服务是管理函数的最小单位，每个函数都只属于一个服务。 服务中可以定义函数可以使用的’角色’和日志输出的仓库，所有函数共享所属服务的这些设定。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E6%9C%8D%E5%8A%A1",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#服务"
  },"81": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "函数",
    "content": "函数是运行代码的容器。用户自己编写需要处理的业务，并放在相应语言的函数容器中运行。 . 注：目前阿里云支持nodejs, python和java . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%87%BD%E6%95%B0",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#函数"
  },"82": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "实现步骤",
    "content": "简单介绍，搭建热更新后端的步骤。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#实现步骤"
  },"83": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "工具",
    "content": "用户可以在阿里云控制台中操作创建服务和函数，更方便的做法是使用行数计算命令行工具fcli进行创建。在下面的步骤中，采用fcli的方式介绍。 fcli下载及文档 . 初次使用fcli需要使用阿里云账号登陆。 注：如果使用子账号登陆，子账号需要有操作RAM和函数计算的授权。 运行： . fcli shell Please input the endpoint (example: https://account_id.cn-shanghai.fc.aliyuncs.com): &gt; [ENDPOINT] Please input the access key id: &gt; [FAKE_ACCESS_KEY_ID] Please input the access key secret: &gt; [FAKE_ACCESS_KEY_SECRET] Store the configuration in: /Users/testuser/.fcli Welcome to the function compute world. Have fun! . 获取endpoint，请参考服务入口文档。 获取access key id/secret，请参考相关文档。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%B7%A5%E5%85%B7",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#工具"
  },"84": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "创建角色授权",
    "content": "当函数计算和其他云资源有交互的时候，需要创建两种角色授权，一种是授权给其他云资源使用触发函数计算的角色， 另一种是授权给函数计算使用云资源的角色。 . 触发函数计算 . 创建触发函数计算角色，用来授权给其他云资源调用函数计算服务。 例如，授权api网关调用函数计算，或对象存储服务触发函数计算。 . 运行： . mkir fc-invoke-function mkrp fc-invoke-all -a '\"fc:InvokeFunction\"' -r '\"*\"' attach -p /ram/policies/fc-invoke-all -r /ram/roles/fc-invoke-function . 对象存储及日志服务读写 . 创建其他云资源调用角色，用来让函数计算服务可以访问日志服务和OSS对象存储服务。 . 运行： . mksr fc-oss-log-op mkrp fc-oss-log-gp -a '[\"oss:GetObject\", \"oss:PutObject\", \"log:PostLogStoreLogs\", \"log:GetLogStore\"]' -r '\"*\"' attach -p /ram/policies/fc-oss-log-gp -r /ram/roles/fc-oss-log-op mks oss_demo -r acs:ram::[ALIYUN ACCOUNT id]:role/fc-oss-log-op . 注：这里为了演示方便，并没有限制具体可操作资源，用户需要更具具体情况合理的限制可操作资源。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2%E6%8E%88%E6%9D%83",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#创建角色授权"
  },"85": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "创建日志库",
    "content": "创建日志库来，用来收集函数日志。 具体步骤可以参考函数访问日志服务 . 这里创建一个日志项目名为fc-beijing， 仓库名为hotpatch的日志库。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%88%9B%E5%BB%BA%E6%97%A5%E5%BF%97%E5%BA%93",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#创建日志库"
  },"86": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "创建OSS",
    "content": "热更新的代码需要存放在OSS中，所以需要创建一个与函数服务在同一个区存储空间。名字为hotpatch, 且读写权限为‘公共读，私有写’。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%88%9B%E5%BB%BAoss",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#创建oss"
  },"87": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "创建函数服务",
    "content": "在阿里控制台选择函数服务，创建名为hotpatchService的函数服务，选择刚创建的日志库hotpatch和fc-oss-log-op这个角色。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E6%9C%8D%E5%8A%A1",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#创建函数服务"
  },"88": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "创建项目",
    "content": "函数服务本身每一个函数都是独立的代码片段处理业务的某一个部分，自身就像一个小的项目。但是，一个服务下的所有函数，却是在处理同一块业务。 . 热更新项目的结构，借鉴了一些开源项目包含多个子项目的代码管理思路，把服务作为一个项目，每一个函数作为子项目。达到，服务的所有函数代码使用同一个代码库管理，但每个函数的代码又是独立的可以自行管理依赖，测试，发布等操作。 . 因为采用nodejs开发，所以使用lerna作为管理项目和子项目的工具。项目目录如下： . ├── README.md ├── lerna.json ├── package.json ├── packages │   ├── getLatestBundle │   │   ├── index.js │   │   └── package.json │   └── uploadBundle │   ├── index.js │   ├── node_modules │   ├── package-lock.json │   └── package.json . packages目录下存放着不同的函数，每个函数是一个文件夹, 使用函数名字命名，例如uploadBundle。没个函数使用package.json管理依赖包。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#创建项目"
  },"89": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "上传UploadBundle代码",
    "content": "在uploadBunde目录下运行 . fcli shell mkf uploadBundle -h index.handler -t nodejs6 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E4%B8%8A%E4%BC%A0uploadbundle%E4%BB%A3%E7%A0%81",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#上传uploadbundle代码"
  },"90": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "上传getLatestBundle代码",
    "content": "上传getLatestBundle代码 . fcli shell mkf getLatestBundle -h index.handler -t nodejs6 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E4%B8%8A%E4%BC%A0getlatestbundle%E4%BB%A3%E7%A0%81",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#上传getlatestbundle代码"
  },"91": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "更新代码",
    "content": "使用编辑器编辑本地代码后，在函数文件夹运行 . fcli shell upf [FUNCTION NAME] -h index.handler -t nodejs6 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#更新代码"
  },"92": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "创建触发器",
    "content": "目前只有OSS对象存储服务，支持创建函数触发器，用户可以定义当存储空间内某些操作执行后触发函数，例如用户上传新的对象后，触发函数。 . 在热更新后台中，需要在有新代码上传后，对代码进行md5计算，并放入测试环境。 . 创建触发器config.yaml, 定义OSS触发函数的事件 . triggerConfig: events: - oss:ObjectCreated:* filter: key: prefix: src/ suffix: .js . 在bash中运行： . mkt uploadBundle -t oss -r acs:ram::[ALIYUN ACCOUNT id]:role/fc-invoke-function -s acs:oss:[REGION]:[ALIYUN ACCOUNT ID]:hotpatch -c config.yaml . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#创建触发器"
  },"93": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "API网关",
    "content": "当使用函数计算作为Web API服务后端时，需要使用API网关来定义Web API的接口，并由API网关转换客户端请求后，调用函数计算服务。 . 在更新后台中，检测版本更新需要以Web API的形式提供给APP客户端访问。 . 步骤： . 在阿里云控制台中打开API网关，创建名为hotpatchAPIGroup的分组 . 创建名为getLatestBundle的API . 安全方式暂时选则无认证，在后面的安全章节中会介绍如何开启认证。 . 创建API . 请求基础定义 . 后端基础定义 . 定义返回结果 . { \"isBase64Encoded\":true|false, \"statusCode\":httpStatusCode, \"headers\":{response headers}, \"body\":\"...\" } . 注：更详细步骤可参考API网关触发函数计算 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#api%E7%BD%91%E5%85%B3-1",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#api网关-1"
  },"94": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "安全",
    "content": "在之前创建API时，选择了无认证，在学习使用函数计算作为API服务后端时是可以简化概念，把重点放在如何链接两个服务上。 在真实项目中，我们依然希望API的访问是可控的，只有授权过的客户端才可以访问。 . API网关服务提供了一种基于应用的认证授权的机制，用户可以在API网关中创建一个应用，并在API中设置安全方式为阿里云APP, 签名算法为HmacSHA256。 之后，在授权信息中添加应用访问API的授权。 . 注：详细步骤可参考授权给应用 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%AE%89%E5%85%A8",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#安全"
  },"95": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "后记",
    "content": "热更新后端作为技术验证项目，已经部署在测试环境，生产环境暂时没有开启。 . 目前，还有几处不完善的地方： . | 发布函数 | 客户端命令行 | 针对不同版本做diff patch，使更新包更小。 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%90%8E%E8%AE%B0",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#后记"
  },"96": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "TODO",
    "content": ". | 公开项目代码 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#todo",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#todo"
  },"97": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "附录",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E9%99%84%E5%BD%95",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#附录"
  },"98": {
    "doc": "阿里函数计算实现简单React Native热更新后台",
    "title": "参考文档",
    "content": ". | 函数服务开发手册 | 以函数计算作为 API 网关后端服务 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3",
    "relUrl": "/docs/react-native/2018-02-11-aliyun-fc-RN-hotpatch-backend.html#参考文档"
  },"99": {
    "doc": "k8s 自制手册",
    "title": "k8s 自制手册",
    "content": "记录在阿里云上手动拉起三节点 k8s 的步骤 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html"
  },"100": {
    "doc": "k8s 自制手册",
    "title": "常用命令",
    "content": "kubectl get pod -n kube-system kubectl get pod -n calico-system -o wide kubectl get pod -o wide kubectl get nodes -o wide # dashboard kubectl --namespace=kubernetes-dashboard get pod -o wide | grep dashboard # delete node on control-panal kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsets sudo rm -rf /etc/kubernetes/ 用 pod 运行一个shell kubectl run -it --rm busybox --image=busybox -- sh . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#常用命令"
  },"101": {
    "doc": "k8s 自制手册",
    "title": "安装 k8s 集群",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E5%AE%89%E8%A3%85-k8s-%E9%9B%86%E7%BE%A4",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#安装-k8s-集群"
  },"102": {
    "doc": "k8s 自制手册",
    "title": "设置阿里云景象",
    "content": "sudo apt update &amp;&amp; sudo apt install -y apt-transport-https curl curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - echo \"deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main\" &gt;&gt;/etc/apt/sources.list.d/kubernetes.list . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E8%AE%BE%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91%E6%99%AF%E8%B1%A1",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#设置阿里云景象"
  },"103": {
    "doc": "k8s 自制手册",
    "title": "安装 Kube 工具",
    "content": "sudo apt-get install -y kubelet kubeadm kubectl sudo apt-mark hold kubelet kubeadm kubectl kubeadm config images pull --image-repository registry.aliyuncs.com/google_containers . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E5%AE%89%E8%A3%85-kube-%E5%B7%A5%E5%85%B7",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#安装-kube-工具"
  },"104": {
    "doc": "k8s 自制手册",
    "title": "安装 Master",
    "content": "sudo kubeadm init \\ --kubernetes-version=v1.21.2 \\ --image-repository registry.aliyuncs.com/google_containers \\ --pod-network-cidr=192.168.0.0/16 \\ --v=6 --ignore-preflight-errors=all \\ &gt; 因 registry.aliyuncs.com/google_containers 为阿里云三方用户维护，同步慢，有时无法获得对应版本，需要从docker hub 拉取，并重新 tag. docker pull coredns/coredns:1.8.0 sudo docker tag 296a6d5035e2 registry.aliyuncs.com/google_containers/coredns:v1.8.0 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E5%AE%89%E8%A3%85-master",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#安装-master"
  },"105": {
    "doc": "k8s 自制手册",
    "title": "安装网络插件",
    "content": "Calico 性能好, 但阿里云只能使用 IPIP 模式，与 flannel 模式一致。建议直接使用Flannel 一定要先配置网络，再加入节点！！！一定要先配置网络，再加入节点！！！一定要先配置网络，再加入节点！！！ 一定要关闭 NetworkManager ！！！https://docs.projectcalico.org/maintenance/troubleshoot/troubleshooting#configure-networkmanager . 安装 Calico [未成功，阿里云上因网络不支持，calico 安装失败] . curl https://docs.projectcalico.org/manifests/calico.yaml -O kubectl apply -f calico.yaml # 如果 pod network 非 192.168.0.0/16 需要先下载 yaml ，手动配置后启动 kubectl create -f https://docs.projectcalico.org/manifests/custom-resources.yaml . 安装 Flannel 【阿里云可用】 . wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml #如果yml中的\"Network\": \"10.244.0.0/16\"和kubeadm init xxx --pod-network-cidr不一样，就需要修改成一样的。不然可能会使得Node间Cluster IP不通。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E5%AE%89%E8%A3%85%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#安装网络插件"
  },"106": {
    "doc": "k8s 自制手册",
    "title": "安装 kube-dashboard",
    "content": "Master 节点运行： . kubectl proxy . 从笔记本访问： . ssh -L localhost:8001:localhost:8001 -NT root@xcode-build.frankwang.cn -i ~/.ssh/xcode-build-env@aliyun . 获取 Token . kubectl -n kube-system get secret|grep admin-token kubectl -n kube-system describe secret admin-token-vtg87 . 三节点时允许 master 运行 Pod, 有安全风险仅可用于开发，测试环境 . kubectl taint nodes --all node-role.kubernetes.io/master- . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E5%AE%89%E8%A3%85-kube-dashboard",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#安装-kube-dashboard"
  },"107": {
    "doc": "k8s 自制手册",
    "title": "ELK 安装 Tips",
    "content": ". | 需要在每一台机器上安装 nfs-common 工具: apt-get install nfs-common | 需要设置每一台机器 sysctl -w vm.max_map_count=262144 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#elk-%E5%AE%89%E8%A3%85-tips",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#elk-安装-tips"
  },"108": {
    "doc": "k8s 自制手册",
    "title": "获取账号",
    "content": "PASSWORD=$(kubectl get secret quickstart-es-elastic-user -o=jsonpath='{.data.elastic}' | base64 --decode) echo $PASSWORD . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E8%8E%B7%E5%8F%96%E8%B4%A6%E5%8F%B7",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#获取账号"
  },"109": {
    "doc": "k8s 自制手册",
    "title": "安装 log-pilot —&gt; kafka —&gt; logstash —&gt; elasticsearch7 —&gt; kibana7",
    "content": "在实际生产环境中，我们的业务日志可能会非常多，这时候建议收集时直接先缓存到KAFKA，然后根据后面我们的实际需求来消费KAFKA里面的日志数据，转存到其他地方，这里接上面继续，我以一个logstash来收集KAFKA里面的日志数据到最新版本的elasticsearch里面（正好也解决了log-pilot不支持elasticsearch7以上版本的问题） . 安装参考 . 安装 Kafka . 建议在 k8s 之外通过 docker- compose 安装 . docker-compose 安装： . | 下载： https://github.com/wurstmeister/kafka-docker | docker-compose up -d | . 裸机安装 Kafka . | 下载：https://kafka.apache.org/downloads | 安装 https://kafka.apache.org/documentation/#quickstart | . *守护进程方式启动命令加 -daemon 。 例如：bin/zookeeper-server-start.sh -daemon config/zookeeper.properties &amp;&amp; bin/kafka-server-start.sh -daemon config/server.properties . Kafka 测试： . 参考官网 . Logstash 配置不校验证书: . ssl =&gt; true # 需要同时设置 ssl_certificate_verification =&gt; false . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E5%AE%89%E8%A3%85-log-pilot--kafka--logstash--elasticsearch7--kibana7",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#安装-log-pilot--kafka--logstash--elasticsearch7--kibana7"
  },"110": {
    "doc": "k8s 自制手册",
    "title": "Nacos 安装",
    "content": "*访问地址一定要带路径: /nacos . # In VM curl -X PUT 'http://192.168.2.29:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080' curl -X GET 'http://192.168.2.29:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName' curl -X POST \"http://192.168.2.29:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=helloWorld\" curl -X GET \"http://192.168.2.29:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test\" ## In Pod curl -X PUT 'http://nacos-headless:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080' curl -X GET 'http://nacos-headless:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName' curl -X POST \"http://nacos-headless:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=helloWorld\" curl -X GET \"http://nacos-headless:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test\" . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#nacos-%E5%AE%89%E8%A3%85",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#nacos-安装"
  },"111": {
    "doc": "k8s 自制手册",
    "title": "安装 MySQL Admin",
    "content": "helm repo add bitnami https://charts.bitnami.com/bitnami helm install mysql-admin bitnami/phpmyadmin . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#%E5%AE%89%E8%A3%85-mysql-admin",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#安装-mysql-admin"
  },"112": {
    "doc": "k8s 自制手册",
    "title": "Reference",
    "content": ". | K8s 安装 | Dashboard 安装 | K8s 搭建step by step | k8s 基础组建相关部署 YAML | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-08-01-k8s-cookbook.html#reference",
    "relUrl": "/docs/2021-08-01-k8s-cookbook.html#reference"
  },"113": {
    "doc": "k8s 崩溃修复",
    "title": "K8S 崩溃排查",
    "content": "记录一次 K8S 意外崩溃，修复思路，和复盘。 . 集群规格： . | 节点名 | 规格 | 说明 | . | Master-01 | 2 CPU, 4 GB | 控制节点（开启允许部署应用） | . | Node-01 | 4 CUP, 8 GB | 运行节点 | . | Node-02 | 4 CPU, 8 GB | 运行节点 | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-09-11-k8s-crash.html#k8s-%E5%B4%A9%E6%BA%83%E6%8E%92%E6%9F%A5",
    "relUrl": "/docs/2021-09-11-k8s-crash.html#k8s-崩溃排查"
  },"114": {
    "doc": "k8s 崩溃修复",
    "title": "安装 Ranucher 导致节点内存不足",
    "content": "崩溃起因为，使用 Helm chart 在 K8S 集群上部署 Rancher 。 安装后，初始状态一切正常，可以看到 local 集群，并进行简单管理。20分钟左右，其中一个 node 内存持续飙升， 导致重启。 集群开始调度 pod 到另外一个 node, 导致另外一个 node 内存飙升。出现雪崩效应。 Master 节点 CPU 使用率 100%。整个集群开始不相应任何请求。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-09-11-k8s-crash.html#%E5%AE%89%E8%A3%85-ranucher-%E5%AF%BC%E8%87%B4%E8%8A%82%E7%82%B9%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3",
    "relUrl": "/docs/2021-09-11-k8s-crash.html#安装-ranucher-导致节点内存不足"
  },"115": {
    "doc": "k8s 崩溃修复",
    "title": "修复思路",
    "content": "因集群上Pod大部分处在内存不足，停止，重启的过程。 无法使用 kubeadmin dashboard 通过 Web 管理集群。仅能通过控制节点上的 kubectl 来链接 K8S，效率低下。所以，先找到一个高效管理的工具， 对集群进行观测。再通过观测结果，做出相应修复方案，并执行。 . 高效的 K8S 终端管理工具 - K9S . K9S 是一套运行在命令行内的管理工具，使用习惯于 VIM 类似。通过K9S可以快速查看集群状况，在终端环境下可以高效运维集群。 . 观测问题 . 在安装 K9S 之后， 通过观测发现 Helm chart 安装的 Rancher，带有全部特性包括多集群管理的 Fleet 特性。因为这些重量级的特性，导致集群内 Node 节点内存始终会被占满，导致重启。 发现了问题，也有了大致的解决问题的方向 —— 将 Rancher 从集群内清除!!! . 修复方案 . 因为本身集群是用来做实验的测试集群，所以并不要求持续可用。 经过与同事讨论，方案有三个。 . 方案一：重置三台虚拟机，使用 RKE 重新拉起 . 方案简单粗暴。对于临时测试集群来说算是一种一了百了的高效方案。 . 优势：使用 RKE 可以快速拉起一套 K8S 集群，不需要太多多人工干预。同时，可以再体验一下 RKE 管理的K8S。 . 劣势：之前群上的一些应用需要重新安装。例如：ELK 全家桶，Nacos 等等。。。 . 方案二：从服务器上产掉K8S，通过 Kubeadmin 手动拉起 . 方案挑战较多。首先，要清理K8S 的残留文件。其次，手动拉起虽然有脚本支持，但也避免不了一些意外情况。 . 优势：可以演练一下产掉 K8S，重新定制化手动拉起的过程。 . 劣势：周期较长，有因为未清理干净，从而导致再次安装出现意外情况的可能。 . 方案三：手动清理 Rancher Stack . 方案对现有集群影响最小。 . 优势：影响最小，可以通过逐个删除 Rancher Stack 的 Namespace 来完成资源删除。可以演练生产环境时，不能删除集群的情况。 . 劣势：有一些挂掉的 K8S 服务需要重新启动，并关联。 . 选择方案，并修复 . 既然是测试集群，本着折腾的原则。决定先采用__方案三__演练一下生产环境不能删除集群时的灾难恢复。 . 删除 Rancher Stack . 删除过程使用 K9S 非常简单高效。通过，namespece 视图选取相应的 namespace 使用 ctrl+d 快捷键即可启动删除操作。 . 等待 K8S 自愈 . 因为控制节点仅仅是 CPU 拉满，当 Rancher Stack 被逐渐删除后，控制节点开始恢复运转。 期间，Node-01 因始终无法接到清理指令，一直无法恢复，只能通过阿里云控制台强行重启。 . 最终，所有节点恢复运转，控制节点开始重新调度上层应用。 . 手动恢复操作 . 集群开始运行后，出现了以下问题几个问题。 . Nacos 无法创建 endpoint . 错误信息： the object has been modified; please apply your changes to the latest version and try again . 经过排查得到官网说明：由于 etcd restore 之后，在重启 kube-apiserver 之前，控制平面各个组件缓存中的 Object 版本跟 etcd 备份中不一致。解决方法是是在 etcd restore 之后，重启控制平面所有组件。 . 通过 k9s 手动重启了所有 kube-system 下的 pod。⚠️注意：要从 pod 视图逐一删除pod。 . Nacos 数据丢失 . Nacos 重新启动后，之前的数据丢失，手动将本地保存的 Config 和 Namespace 恢复。 这个原因带排查，初步猜测原因是 Node 挂掉后，mysql Pod 被调度到另外一个节点，并重新初始化了数据库。或是，在恢复 Nacos 过程中失误删掉了数据库。 . 手动拉起 Kafka . 集群正常启动后，发现日志没有进去 elasticsearch。 因为，之前 Kafka 是部署在 K8S 集群之外的 Node-01 上。所以，需要手动在 Node-01 上通过 docker-compose 启动。 . 一切恢复 . 经过一番折腾，在没有删除集群的情况下，将服务逐一恢复。历时 6 个小时，如果是真正的线上问题，已经可以定级为__严重故障__。 . 所以，需要复盘一下。 . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-09-11-k8s-crash.html#%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF",
    "relUrl": "/docs/2021-09-11-k8s-crash.html#修复思路"
  },"116": {
    "doc": "k8s 崩溃修复",
    "title": "复盘",
    "content": "关键问题点 . | 在使用 Helm 安装 Rancher 之前，虽然检查过 Pre-requirement，但是对于要求的服务器规格理解不到位。导致没有准确评估出现有集群规格无法满足部署条件。 | 集群再部署前内存水位线已接近临界值，但并没有被注意到。 | 集群挂掉之前，并没有灾备预案。导致恢复过程属于“摸石头过河”。 | 运维自动化程度不够，无论是重新拉起，还是恢复上层应用都需要手动操作。 | . 经验教训 . | 部署前一定要详细了解 Pre-requirement，做好风险分析 | 生产级集群在部署新应用前，要做容量估算和检查，预留好充足资源 | 生产级集群需要有灾备预案，并定期进行演练，以提高运维团队应对突发状况的能力 | 添加自动化运维能力，例如: Ansible, Terraform | . ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-09-11-k8s-crash.html#%E5%A4%8D%E7%9B%98",
    "relUrl": "/docs/2021-09-11-k8s-crash.html#复盘"
  },"117": {
    "doc": "k8s 崩溃修复",
    "title": "k8s 崩溃修复",
    "content": " ",
    "url": "http://next.yanqiw.qianyitian.com/docs/2021-09-11-k8s-crash.html",
    "relUrl": "/docs/2021-09-11-k8s-crash.html"
  }
}
